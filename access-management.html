<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="./css/bootstrap.min.css" />
    <link rel="stylesheet" href="./css/owl.carousel.min.css" />
    <link rel="stylesheet" href="./css/all.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <title>StorX Network</title>
  </head>
  <body>
    <header>
      <div class="top-header">
        <div class="container">
          <div class="row align-items-center">
            <div class="col-5">
              <ul class="social-media-wrapper">
                <li>
                  <a href="https://www.facebook.com/StorXNetwork" target="_blank">
                    <img
                      src="./images/icons/facebook-icon.svg"
                      alt="facebook"
                    />
                  </a>
                </li>
                <li>
                  <a href="https://twitter.com/StorXNetwork" target="_blank">
                    <img src="./images/icons/twitter-icon.svg" alt="twitter" />
                  </a>
                </li>
                <li>
                  <a href="https://www.linkedin.com/company/storxnetwork/" target="_blank">
                    <img src="./images/icons/linkdin.svg" alt="linkdin" />
                  </a>
                </li>
                <li>
                  <a href="https://www.youtube.com/channel/UC5vUiX1eINl0gs6T3mS1CxA" target="_blank">
                    <img src="./images/icons/youtube-icon.svg" alt="youtube" />
                  </a>
                </li>
              </ul>
            </div>
            <div class="col-7 text-end">
              <ul class="user-sign-in-wrapper">
                <li>
                  <a href="https://storx.io/new"
                    ><img src="./images/icons/sign-up-icon.svg" alt="signup" />
                    <span>Sign Up</span></a
                  >
                </li>
                <li>
                  <a href="https://storx.io/login"
                    ><img src="./images/icons/login-icon.svg" alt="login" />
                    <span>Login</span></a
                  >
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <div class="bottom-header">
        <div class="container">
          <div class="row align-items-center g-0">
            <div class="col-md-4 col-9">
              <a href="index.html" class="logo">
                <img src="./images/start-logo.svg" alt="logo" />
              </a>
            </div>
            <div class="col-md-8 col-3 text-end pe-md-3">
              <nav>
                <ul class="main-menu">
                  <li class="manu-link">
                    <a href="javascript:void(0)">SOLUTION</a>
                    <ul>
                      <li><a href="storx-secured-storage.html">StorX Secured Storage</a></li>
                      <li><a href="storx-for-saas-backup.html">StorX For SaaS BackUp</a></li>
                      <li><a href="storx-onprem.html">Self-Hosted Cloud</a></li>
                    </ul>
                  </li>
                  <li class="manu-link">
                    <a href="javascript:void(0)">TECHNOLOGY</a>
                    <ul>
                      <li><a href="blockchain.html">Blockchain Technology</a></li>
                      <li><a href="ecosystem.html">XDC Ecosystem</a></li>
                    </ul>
                  </li>
                  <li class="manu-link">
                    <a href="use-cases.html">USE CASES</a>
                  </li>
                  <li class="manu-link"><a href="javascript:void(0)">RESOURCES</a>
                    <ul>
                      <li><a href="https://storx.tech/storx_whitepaper_v1.pdf" target="_blank">Whitepaper</a></li>
                      <li><a href="roadmap.html">Roadmap</a></li>
                      <li><a href="https://medium.com/storx-network" target="_blank">Blog</a></li>
                      <li><a href="faqs.html">FAQ</a></li>
                      <li><a href="community-bounty.html">Community Bounty</a></li>
                      <li><a href="exchange-listing-resource.html">Exchange Listing Resource</a></li>
<!--                      <li><a href="#">Brand Assets</a></li>-->
                    </ul>
                  </li>
                  <li class="manu-link">
                    <a href="javascript:void(0)">About</a>
                    <ul>
                      <li><a href="about-team.html">About Us</a></li>
<!--                      <li><a href="#">StorX Token</a></li>-->
                      <li><a href="wallets-&-exchanges.html">Wallets & Exchanges</a></li>
                    </ul>
                  </li>
                </ul>
                <span class="toogle-btn" role="button">
                  <i class="fa-solid fa-bars"></i>
                  <i class="fa-solid fa-xmark"></i>
                </span>
              </nav>
            </div>
          </div>
        </div>
      </div>
    </header>

    <section class="banner faq-banner inner-banner">
      <div class="container">
        <div class="content-wrapper">
          <h1>Access Grant</h1>
        </div>
      </div>
    </section>

   <section class="terms-condition">
     <div class="container small">
       <h3>Access Management</h3>
       <p>Decentralized and distributed cloud storage offers an efficient way to utilize untapped
         storage with bandwidth resources. However, in order to ensure the availability and durability
         of the StorX cloud storage, privacy controls, and security are imperative.</p>

       <p>Given the necessity to operate under assumptions that any Peer Class, apart from the
         Uplink, may be controlled by untrusted entities, we have implemented a zero-knowledge
         security architecture.  This approach not only fortifies our system against attack when
         compared to traditional architectures but also confers substantial advantages to developers
         constructing applications on the StorX platform.</p>

       <h3>Access Control Paradigm</h3>
       <p>The access control paradigm within StorX is grounded in a set of security and
         privacy principles, integrated at the code level as an essential element of the
         decentralized architecture. These principles also serve as a feature to empower
         developers in the development of more secure and private applications.</p>

       <ul>
         <li>All data and metadata stored on StorX undergo encryption, with encryption keys kept beyond the reach of the Satellite</li>
         <li>Authorization management is intended to be decentralized while providing user-friendly tools for precise access control</li>
         <li>Authorization management is intended to be decentralized while providing user-friendly tools for precise access control</li>
       </ul>

       <p>These security and privacy principles are realized in StorX as a toolkit that developers
         can employ for access control that enables them to exercise meticulous oversight over data
         access and sharing within their applications, atop a decentralized and distributed system. </p>

       <p>Access control within StorX necessitates the synchronization of two concurrent constructs:</p>

       <ol>
         <li>Authorization - An assessment of the legitimacy of a specific request to execute an action
           on a resource. Authorization management is executed via hierarchically deterministic API keys,
           based on macaroons.</li>
         <li>Encryption - Data and metadata residing on StorX are subjected to encryption using
           hierarchically deterministic Encryption keys. Objects are encrypted with a randomly generated
           encryption key, augmented by a predetermined salt. Paths and randomized encryption keys are
           encrypted using AES 256 GCM or Secretbox with a passphrase.</li>
       </ol>

       <p>Both these constructs work collaboratively which furnish an access control framework
         that is both secure and private while also being highly adaptable for application developers.</p>

       <p>To facilitate the implementation of these constructs for developers, StorX developer tools
         abstract the intricacies of encoding objects for access control and encryption/decryption,
         simplifying the process.</p>

       <p>Understanding the synergy between Authorization and Encryption is crucial
         for designing an appropriate access control workflow for an application.</p>


       <h3>Fusion of Authorization and Encryption Management: Access Grants</h3>
       <p>StorX employs hierarchically deterministic Access Grants as an access tool layer for objects.
         An Access Grant comprises a security envelope encompassing a satellite address, a restricted API
         key, and a restricted path-based encryption key. This bundle equips an application with all the
         necessary components to locate an object on the network, access it, and decrypt it. The key benefit
         of this approach is that Access Grants and associated restrictions can be managed entirely on the
         client side which obviates the need for central Access Control Lists or other server-side mechanisms
         in the access control process. This approach is referred to as delegated authorization.</p>

       <h3>Access Grants - An Overview</h3>
       <p>An Access Grant serves as a bearer token designed to facilitate interactions between applications
         and StorX DCS that allows access to stored objects on the service while enabling client-side decryption. </p>

       <p>Access Grants essentially function as a security container that encompasses vital components: a
         satellite address, a restricted API key, and a set of one or more constrained prefix-based encryption
         keys. These elements collectively empower an application to identify and access objects within the
         network and subsequently decrypt them. </p>

       <h3>Developer Access Management Tool</h3>
       <p>Access Grants harmonize two concurrent constructs, encryption, and authorization. This synchronization
         simplifies the data-sharing process which eliminates the need for managing access control lists or
         navigating complex encryption tools. These integrated constructs form a client-side access management
         framework that ensures both security and privacy while affording exceptional flexibility to application
         developers.</p>

       <p>Access Grants are integral for access management in client applications utilizing the lib uplink
         library, the Command Line Interface (CLI), and the generation of credentials for the S3-compatible
         gateway, including both the hosted GatewayMT and the self-hosted GatewayST. </p>

       <p>To streamline the implementation of these constructs for developers, StorX developer tools abstract
         intricacies of encoding objects for access management and encryption/decryption. A straightforward
         “share” command encapsulates an encryption key, an API key, and the relevant satellite address within
         an encoded string referred to as an Access Grant.</p>

       <p>Access Grants can be effortlessly imported into an Uplink client, whether in the form of the CLI,
         developer library, or a client application. These imported Access Grants are under the control of the
         client side and can be employed within the application through the Uplink client library. </p>

       <p>Facilitated through the CLI or libuplink library, Access Grants are subject to restrictions, both
         on the server side (the Satellite) and the client side. These restrictions are managed through a
         serialized, hierarchically derived structure. In the process of generating restricted access grants,
         both the API key and the encryption key are automatically derived from the parent Grant Access.</p>

       <p>StorX satellites never encounter encryption keys. When an access grant is utilized with the CLI, libuplink
         library, or the self-hosted Gateway, the encryption keys are managed on the client side, employing a serialized,
         hierarchically derived structure to ensure end-to-end encryption. However, with the cloud-hosted Gateway-MT, your
         data undergoes server-side encryption, as StorX hosts the gateway.</p>

       <strong>API Key </strong>

       <p>API Keys in the context of StorX DCS are crafted using a mechanism rooted in macaroons, incorporating
         the capability to embed programmatic access limitations within the API key. </p>

       <p>The API key which is encoded within an Access Grant, is founded upon a token known as a Macaroon.
         Essentially, a Macaroon can be likened to a cookie that possesses an intrinsic structure for encoding
         logical operations, in this instance, access restrictions. The Macaroon encapsulates the logic pertaining
         to the access it permits. It can be constrained by the inclusion of path limitations and supplementary
         restrictions within the strings that represent the Macaroon. Diverging from the characteristics of a conventional
         cookie, a Macaroon is not a random sequence of bytes; instead, it takes the form of an envelope that houses encoded
         access logic.</p>

       <p>StorX DCS streamlines the process of privately and securely sharing access to objects. You’re not required to master
         the intricacies of crafting an API key, but having a grasp of proper functioning and capabilities equips you with an
         in-depth comprehension of the tools at your disposal with the StorX DCS. These tools empower you to construct applications
         that are both more private and secure.</p>

       <strong>API Key Overview</strong>

       <p>If you want to understand Macaroons in a more comprehensive way, learn about them on
         <a href="https://ai.google/research/pubs/pub41892" target="_blank">Google</a> Paper.
         This documentation is designed to provide sufficient information for the effective use of StorX DCS access
         management and object-sharing features. However, it does not aim to provide a comprehensive explanation of
         the full range of Macaron functionality. </p>

       <p>This documentation may use the terms “API Key” and “Macaroon” interchangeably, it’s important to note
         that only the term “Access Grant” is officially referenced within the service, its libraries,  and in
         the documentation. The API key is encapsulated within an Access Grant and doesn’t require separate management. </p>

       <strong>Access Management Commences at the Project Level</strong>

       <p>Each project possesses a Root API Key Secret issued by the Satellite. This Root API Key Secret serves as the
         foundation for generating other API keys. Given that all Access Grants originate from the same Root API Key
         Secret, they all share the same level of access. By default, all API Keys enjoy unrestricted access to perform
         all functions related to objects within a project. </p>

       <strong>Access Encoding by Uplink Client</strong>

       <p>When a Uplink client such as LibUplink, Uplink CLI, or Uplink S3 Gateway is configured to employ an Access
         Grant, the Uplink Client automatically generates an HMAC signature, which is then encoded in the metadata of
         the stored object. As objects are created, along with their path metadata, the hierarchal structure is encoded
         within the object metadata. This encoding allows the derivation of a restricted Grant Access for any level of
         the hierarchy, provided the parent Access Grant is known. This restricted Access Grant remains valid from the
         specified point in the hierarchy and extends downward to encompass all child objects within that hierarchical
         segment. </p>

       <strong>Facilitating Access Object Sharing</strong>

       <div class="img-wrapper">
         <img src="./images/facilitating-access.png" alt="img">
       </div>

        <p>Once the Uplink client creates an Access Grant, this Access Grant can be shared with a peer, which is
          another Uplink client. When the peer uplink client uses the Access Grant to request access to an object,
          it forwards the only API key to the relevant Satellite, without revealing the encryption key. The Satellite
          is capable of validating the API Key provided to it, in conjunction with any associated Caveats
          (as described below), without requiring access to the actual metadata. This is of paramount importance to
          consider that the metadata is also encrypted on the client side.</p>

       <p>In essence, the Satellite does not need to be informed about the specific user or application seeking
         access to an object, or the nature of the object itself. The Uplink Client conveys only the essential
         information that enables the Satellite to ascertain the validity of the access request, without any knowledge
         about the requester or the object in question.</p>

       <strong>Incorporating Limitations into an Access Grant</strong>

       <p>An Access Grant can also be restricted to grant only a specific level of access to an object, and these
         restrictions are implemented using what is known as "Caveats." Caveats are conditional access restrictions
         that are encoded within the body of an API Key.</p>

       <p>An API Key comprises three primary components: a head, a list of caveats, and a tail. These components
         are concatenated and serialized together. An API Key without any restrictions, referred to as an "unrestricted
         API Key," consists solely of a head and a tail. The head is a random nonce, and the tail of an unrestricted API
         Key is the HMAC (Hash-based Message Authentication Code) of the root secret and the head.</p>

       <p>The following section will delve into the specific limitations applied to bucket and object constructs in more detail.</p>

       <strong>Precise Control Over Access</strong>

       <p>Access limitations, known as Caveats, are seamlessly embedded within the API Key as part of an Access Grant.</p>

       <p>Fine-Grained Authorization via Caveats</p>

       <p>The API Key, within an Access Grant, is automatically imbued with access restrictions during the creation of an
         Access Grant, be it through the Satellite Admin Console, the CLI, or the libuplink library when utilizing the Share
         command. While the range of access controls that can be encoded within a Caveat is virtually boundless, StorX DCS
         currently supports the following specific Caveats:</p>

       <p><strong>Specific Operations:</strong> Caveats can curtail whether an Access Grant can authorize any of the
         subsequent operations:</p>

       <ul>
         <li>Reading</li>
         <li>Writing</li>
         <li>Deleting</li>
         <li>Listing</li>
       </ul>

       <p><strong>Bucket:</strong> : Caveats can restrict whether an Access Grant is empowered to perform actions on one or multiple Buckets.</p>

       <p><strong>Path and Path Prefix:</strong> Caveats can limit whether an Access Grant can authorize actions on Objects situated
         within a particular path within the object hierarchy.</p>

       <p><strong>Time Window:</strong> Caveats can restrict when an Access Grant is effective for operations on objects stored on
         the platform, whether before or after a specific date and time or within a designated time frame.</p>

       <p>The <a href="https://github.com/storj/common/blob/main/macaroon/apikey.go" target="_blank">code linked to the supported Caveats</a>
         on the Satellite can be reviewed on GitHub. When an Access Grant is generated for sharing access to an object, it serves as a
         critical component because the object's retrieval relies on the API Key within the Access Grant and subsequent decryption using
         the encryption key.</p>

       <p>Whenever a Uplink Client initiates an action request on an object to the Satellite, the Satellite assesses the validity of the Access Grant.
         The requested action is permitted if the Access Grant is valid for the action and the specific object.</p>

       <p>In the context of sharing read access to an object, the Access Grant not only enables a Uplink Client to retrieve file fragments and
         reassemble them into a complete file but also necessitates the client's capability to decrypt the encrypted file. This dual functionality
         is vital for effective file sharing.</p>

       <strong>Select Between the StorX Console and the CLI (contains links that redirect to documents)</strong>

       <p>Determining the appropriate tool for generating Access Grants hinges on the intended application of the tool.
         You have the option to create an Access Grant via the StorX Console leverage our Go Library, or use the "Create
         Access Grant" function in the CLI.</p>

       <strong>When to Utilize the StorX Console</strong>

       <p>In general, the StorX Console is best suited for generating an Access Grant that will subsequently be employed to
         configure the client tool of your choice. To set up and configure the CLI or applications like FileZilla Native
         Integration or Rclone, you must first create an Access Grant within the StorX Console. This Access Grant can be
         unrestricted or, alternatively, a Restricted Access Grant with limited access. The StorX Console also generates
         credentials if you intend to use an application with the StorX-hosted S3-compatible gateway.</p>

       <p><i>Remember: When generating credentials for the StorX-hosted S3-compatible gateway using an Access Grant,
         server-side encryption is applied. If your use case necessitates end-to-end encryption, you should encrypt
         your data before transmitting it to the hosted gateway or consider utilizing a self-hosted S3-compatible Gateway.</i></p>

       <strong>When to Employ a Uplink Client</strong>

       <p>Once you've successfully created an Access Grant via the StorX Console, the CLI, client library, or other
         client tools can utilize this Access Grant to engage with the StorX service. Furthermore, you can create
         additional restricted Access Grants, which are essentially child Access Grants derived from the parent Access
         Grant generated within the StorX Console. The Uplink Client is the ideal choice for generating these additional
         child Restricted Access Grants.</p>

       <p><i>Note: When creating child Restricted Access Grants based on a parent Restricted Access Grant, the child Access
         Grants can possess the same level of access as the parent or have reduced access, but never more.</i></p>

       <p><i>For example: A parent parent-restricted access Grant with only Read and Write access to a specific resource
         can be employed to generate child child-restricted access Grants with read-only access to the resource or even
         just one specific path within that resource. However, a parent Restricted Access Grant with Read and Write access
         to a specific resource cannot be used to create child Restricted Access Grants with Read-Write-Delete access to
         the resource or any other path within a different resource to which the parent Restricted Access Grant lacks access.</i></p>

       <p>For a deeper dive, you can explore the Key Architecture Constructs section or delve into the comprehensive details of Access Management.</p>

       <p>Learn how to Create an Access Grant in the CLI via the StorX Console.</p>
       <p>Learn how to Create an Access Grant in the CLI in the Uplink CLI Tutorial.</p>

       <strong>Edge-Based Access Management (also contains links)</strong>

       <p>In this discussion, we delve into the implementation approach and the advantages of an edge-based delegated authorization model.</p>

       <p>High Interest in Our Security Model</p>

       <p>One of the aspects that has garnered the greatest interest from developers, customers, and partners involved in building applications
         on our platform is our security model and access control layer. The security and privacy features of our platform stand out and offer
         our partners and customers valuable tools.</p>

       <strong>The Necessity of Robust Security and Privacy in Decentralized Architecture</strong>

       <p>While distributed and decentralized cloud storage is an excellent way to optimize underutilized storage and bandwidth,
         delivering highly available and durable cloud storage requires the integration of sophisticated security and privacy
         controls. Given that we had to operate under the assumption that an untrusted individual could potentially run any Node,
         we made the deliberate choice to implement a zero-knowledge security architecture. This approach not only enhances the
         resilience of our system against attacks compared to traditional architectures but also extends substantial benefits to
         developers constructing applications on our platform.</p>

       <strong>The Imperative of Privacy and Security in Decentralization</strong>

       <p>From a network perspective, it is imperative to safeguard the privacy and security of data stored on our platform.
         At a fundamental level, we must ensure that data stored on untrusted Nodes remains inaccessible, safeguarding it
         from compromise or unauthorized access. We deploy a combination of technologies to achieve data privacy, security,
         and availability.</p>
       <p>On the client side, we employ a combination of end-to-end encryption, erasure coding, and API Keys. Erasure coding
         primarily contributes to data availability, and the act of distributing data across numerous diverse Storage Nodes
         also enhances security by eliminating any central repository of data.</p>
       <p>As an illustration, when a file or segment undergoes erasure coding, it is divided into 80 pieces, with any 29 being
         adequate to reconstruct the encrypted file. Within our zero-knowledge architecture, each Node Operator receives only
         one of the 80 pieces. No information in the anonymized metadata indicates the segment to which the piece belongs, or
         the locations of the other 80 pieces, and so on. It's important to note that 80 pieces represent the minimum number of
         pieces for a single object. For files exceeding 64MB, they are broken into 64 MB segments, each of which is further
         subdivided into 80 pieces, resulting in a total of 1,280 pieces for a 1GB file, for instance.</p>
       <p>In the event that a hacker seeks to access a complete object, they must locate at least 29 Nodes that each possess
         a piece of every segment. They would need to compromise the security of each Node (operated by different individuals,
         on various Nodes, with distinct firewalls, etc.). Even then, the hacker would only obtain the encrypted file. They
         would need to repeat this process for each subsequent segment. This stands in stark contrast to incidents like the
         one witnessed at Equifax a few years ago, where a simple misconfiguration exposed the data of hundreds of millions
         of individuals. This underscores the strength of our new security model.</p>

       <strong>Share Access to Data in a Decentralized Environment</strong>

       <p>Just the act of storing data on StorX DCS yields significant advantages over centralized data storage by minimizing
         the threat surfaces and susceptibility to numerous common attack vectors. However, it's when developers aim to share
         access to data, especially highly sensitive data, that the true benefits of our platform become apparent. This is
         where we observe the most interest from partners, especially in the amalgamation of end-to-end encryption and the
         access management capabilities of our API Keys.</p>

       <strong>Segregate Access and Encryption</strong>

       <p>One of the noteworthy features of StorX DCS is the separation of the encryption function from the access management
         capabilities facilitated by API Keys, allowing for the complete management of both on the client side. From a
         developer's standpoint, managing these two constructs is simplified, as the complexity is distilled into a few
         straightforward commands. This empowers developers to transition access management from a centralized server to the edge.</p>

       <strong>Hierarchically Deterministic End-to-End Encryption</strong>

       <p>Every piece of data stored on StorX DCS is encrypted from the client side. This means that users retain control over the
         encryption keys, ensuring an exceptionally private and secure data repository. Both objects and their associated metadata
         are encrypted using randomized, salted, path-based encryption keys. These randomized keys are subsequently encrypted with
         keys generated from the user's encryption passphrase. Neither StorX nor any of the Storage Nodes possess access to these
         keys, the data, or the metadata.</p>

       <p>By employing hierarchically derived encryption keys, it becomes effortless to share the ability to decrypt a single object
         or a group of objects without revealing the private encryption passphrase or having to re-encrypt the objects. In contrast
         to HD API Keys, where the hierarchy is derived from further access restrictions, the foundation of the encryption structure
         is the path prefix structure of the object storage hierarchy.</p>

       <p>A unique encryption key can be derived client-side for each object, whether it's a path or a file. This unique key is
         automatically generated when sharing objects, allowing users to share individual objects or paths. Importantly, this
         approach eliminates the need to separately manage encryption access to objects that are not being shared.</p>

       <strong>Access Management via API Keys</strong>

       <p>In addition to providing the tools for sharing the ability to decrypt objects, StorX DCS offers advanced tools for
         managing access to objects. StorX DCS employs hierarchically deterministic API Keys as an access management layer for
         objects. Similar to HD encryption keys, HD API Keys are derived from a parent API Key.</p>

       <p>Unlike HD encryption keys, where the hierarchy is based on the path prefix structure of the object storage hierarchy,
         the hierarchy of API Keys is rooted in the structure and relationships of access restrictions. HD API Keys encapsulate
         the logic for the access they authorize and can be constrained simply by embedding path restrictions and additional
         restrictions within the API Key's string representation. Unlike a conventional API key, the StorX DCS API Key is not a
         random string of bytes but an envelope with encoded access logic.</p>

       <strong>Bring It All Together with Access</strong>

       <p>Effective access management on StorX DCS necessitates the coordination of the two parallel constructs mentioned
         earlier: encryption and authorization. Both of these constructs operate harmoniously to establish a secure and
         private access management framework, with both encryption and delegation of authorization being managed on the client side.</p>

       <p>It's essential to highlight that, while both constructs are managed on the client side, only the API Keys are transmitted
         to the Satellite. The Satellite interprets the client's restrictions, conveyed in the form of caveats, and subsequently
         governs which operations are permitted based on these restrictions. Importantly, encryption keys are never
         transmitted to the Satellite.</p>

       <strong>Share Access to Objects</strong>

       <p>Sharing access to objects stored on StorX DCS involves transmitting encryption and authorization information
         regarding the object from one client to another. This information is encapsulated within a construct known as
         an Access. An Access functions as a security envelope, containing a restricted HD API Key and an HD encryption key.
         This package equips an application with everything it needs to locate an object on the network, access that object,
         and decrypt it.</p>

       <p>To simplify the implementation of these constructs for developers, the StorX DCS developer tools abstract the
         intricacies of encoding objects for access management and encryption/decryption. A straightforward share command
         packages both an encryption key and an API Key within an Access, formatted as an encoded string that can be easily
         imported into a Uplink client. These imported Accesses are managed on the client side and can be utilized within
         applications through the Uplink client library.</p>


       <strong>Why Edge Security Is Crucial in Modern Computing</strong>

       <p>The progression of cloud services and the migration of services from on-premises to centralized
         cloud environments have brought about significant gains in efficiency and economies of scale. However,
         this efficiency often comes at the expense of a delicate balance between security and privacy. Many emerging
         business models prioritize user convenience over safeguarding user data privacy. In this era of cloud computing,
         the security of users' most sensitive data is at a heightened risk, leading to the emergence of stricter regulatory
         frameworks for data protection.</p>

       <strong>The Nexus of Cybersecurity Expertise and Decentralized Data Management</strong>

       <p>The shift from on-premises to the cloud has led to a reduction in various types of cyberattacks, largely due
         to the enhanced cybersecurity expertise provided by cloud service providers. A prime example of this is the
         transition to Gmail, which is far less susceptible to hacking compared to privately operated mail servers.</p>
       <p>Nonetheless, this migration to the cloud has resulted in a considerable separation between security expertise
         and the use of technology. The cost of top-tier security expertise from cloud providers is distributed across all
         customers. However, this separation has its consequences, such as a lack of transparency and, in some cases,
         compromising user privacy in exchange for enhanced security.</p>
       <p>This is where a decentralized, edge-based security model shines, offering robust security without the trade-offs
         associated with transparency or privacy. With StorX, you gain access to a wealth of expertise in distributed storage,
         encryption, security, and privacy while also enjoying full transparency due to the open-source nature of the software.
         This unique combination empowers users not only to trust but also to verify the platform's security. StorX not only
         provides the security benefits of a cloud storage service but also equips users with the tools to regain control
         over their privacy.</p>

       <strong>Edge-based Security + Decentralized Architecture = Inherent Privacy</strong>

       <p>Traditional authorization technologies are designed for client-server architectures, focusing on synchronous
         transactions that involve a central authority, relying on it for success. To maximize privacy and security at
         a massive scale, it's essential to efficiently delegate resource authorization away from centralized entities.</p>
       <p>Shifting token generation and delegation closer to the architectural edge marks a fundamental shift in how trust
         systems are created. In a distributed system, centrally initiating trust and deriving specific scoped keys from this
         trust allows for the generation of trust chains that are easily managed for specific roles and responsibilities.
         Authorization delegation is handled at the edge but rooted in a common, transparent trust framework. This approach
         ensures that access tokens generated at the edge can be interpreted centrally, without access to the underlying encrypted data.</p>
       <p>Distributed and decentralized environments are designed to minimize trust. By relocating security, privacy, and access management
         to the edge, users regain control over their data. Client-side encryption, cryptographic audits, and a completely open-source
         architecture help mitigate trust boundaries and risk, not through the service provider, but through user-controlled tools.</p>

       <strong>A Fresh Perspective Yields Inherent Value</strong>

       <p>StorX DCS's distributed cloud storage and edge-based security model offer user-friendly tools for constructing applications that
         prioritize privacy, security, and resilience against common attacks. With this approach, no unskilled or malicious operator can
         compromise security. Embracing decentralization and edge security ensures the system's resilience. Unlike other cloud storage providers,
         like AWS Detective, StorX DCS integrates security features that are enabled by default. With StorX DCS, you don't need to pay extra
         for security and privacy.</p>

       <p><strong>Reduced Risk</strong> - Common attacks, such as misconfigured access controls, leaky buckets, insider threats, honeypots,
         and man-in-the-middle attacks, rely on breaching a central repository of access controls or gaining access to a centralized data hub.
         The StorX DCS security model is designed to eliminate entire categories of typical application attack vectors.</p>
       <p><strong>Reduced Attack Surface</strong> - By separating trust boundaries and distributing access management and storage
         functions, a substantial portion of the usual application attack surface is either eliminated or made significantly more complex to breach.</p>
       <p><strong>Enhanced Privacy </strong> - With peer-to-peer access management, the platform provides tools to separate the responsibilities for
         creating bearer tokens for access management from encryption for data usage. This separation enables the decoupling of storage, access
         management, and data utilization, ensuring enhanced privacy with greater transparency.</p>

       <strong>Tailored for Distributed Data</strong>
       <p>The architecture of distributed data storage, combined with edge-based encryption and access management, safeguards your data as if
         it were securely stored on an encrypted virtual beach. The combination of client-side HD Encryption keys and HD API Keys in an accessible
         platform empowers developers to leverage the capability-based security model, enabling the creation of applications that deliver superior
         privacy and security.</p>

       <h3>Access Revoke Mechanisms</h3>
       <p>StorX DCS simplifies the process of revoking client-side delegated authorization through hierarchically deterministic API keys.</p>
       <p>While the concept of delegated authorization and the generation of Access Grants at the edge offers the potential to build more
         secure and private applications, it's essential to consider certain design aspects when developing applications that involve sharing
         data using long-lived bearer tokens.</p>
       <p>To maintain control and security, the ability to revoke access to data is a critical feature. StorX DCS supports access grant
         revocation in two distinct ways:</p>
       <ol>
         <li>
           <strong>Deleting a Primary Access Grant</strong>
           <p>From the Satellite Admin Console, you have the option to delete a primary Access Grant. This action immediately renders all child
             Restricted Access Grants, which were derived from that primary Access Grant, invalid.</p>
         </li>
         <li>
           <strong>Adding an Access Grant to the Revocation Service</strong>
           <p>You can also revoke an Access Grant by adding it to the authorization revocation service, effectively invalidating the associated
             API Key (along with any child Restricted Access Grants that stem from it). This can be conveniently executed through the CLI.</p>
         </li>
       </ol>

       <p>Let's consider a scenario where you have used a primary Access Grant to generate numerous child Restricted Access Grants. If you
         delete the primary Access Grant, it promptly revokes all the Access Grants derived from that primary Access Grant. Conversely,
         adding one of the child-restricted Access Grants to the Access Revocation service invalidates solely that Access Grant and any of
         its derived child Restricted Access Grants. Deleting a Primary Access Key serves the same purpose as including it in the Access
         Revocation service.</p>
       <p>The key distinction lies in the fact that primary Access Grants are created from the Satellite Admin Console, and consequently,
         the Satellite is aware of the creation of the associated API Key. However, the Satellite lacks visibility into whether further child
         Restricted Access Grants were generated on the client side. While this approach significantly enhances the privacy of application
         sharing, it necessitates prudent management of the associated Access Grants.</p>

       <h3>Capability-Based Access vs. Access Control Lists: Better Security Model</h3>

       <p>When it comes to security design, the capability-based access model offers a fundamentally superior approach to identity and
         access management compared to the Access Control Lists (ACL) framework commonly used in public cloud environments.</p>
       <p>In the capability-based model, access is tied to specific keys rather than a centralized control system. This shift pushes
         security to the edge, decentralizing the significant attack vector associated with ACLs and establishing a more robust Identity
         and Access Management (IAM) system.</p>
       <p>Here's why the capability-based model outshines ACLs:</p>
       <ol>
         <li>
           <strong>Decentralization of Access </strong>
           <p>Capability-based models tie access directly to cryptographic keys, allowing users to have fine-grained control over
             their data. This decentralization minimizes the risk of a centralized control system becoming a single point of failure or attack.</p>
         </li>
         <li>
           <strong>Mitigation of Security Pitfalls </strong>
           <p>The capability-based model inherently addresses security challenges like the ambient authority trap and the confused
             deputy problem. This means that unauthorized or unintended actions are less likely to occur, enhancing the overall security posture.</p>
         </li>
       </ol>

       <strong>But what exactly is a capability?</strong>

       <p>A capability, often referred to simply as a "key," is a unique and unforgeable token of authority that both designates a resource
         and authorizes a specific type of access to that resource. If you're familiar with the world of blockchain, you'll recognize the
         capability-based security model as it's employed in Bitcoin, where the phrase "your key is your money" holds true. </p>
       <p>The Capability Mindset emphasizes the importance of not separating designation from authority. In the context of decentralized
         cloud storage like StorX DCS, your keys represent your data. Access grants are the means by which you can add additional capabilities,
         allowing data owners to control their data and selectively delegate access for sharing or automated processes.</p>
       <p>Key-based ownership of object data empowers users to naturally manage their data as a core principle and delegate it as needed.
         The decentralized cloud, such as StorX DCS, eliminates the growing risk of data loss or extortion associated with relying on a single
         provider like Amazon, Google, or Microsoft.</p>
       <p>StorX DCS offers a superior model where object data is encrypted, erasure-coded, and distributed across a vast network of nodes,
         each with its reputation. In this environment, virtually any computer can become part of the cloud, ensuring data security and availability.</p>


       <h3>Understanding Encryption and Encryption Keys in StorX</h3>

       <p>Effective management of encryption keys is a critical aspect of StorX's data storage system. StorX ensures that your data remains secure by
         encrypting it, and you, as the user, are the sole custodian of the encryption keys. The service neither has access to nor stores your encryption
         keys. It's essential to note that losing your encryption keys, including the Access Grant containing your encryption passphrase, means that you
         won't be able to recover your data.</p>

       <strong>Encryption and Access Grants</strong>

       <p>In StorX, an API Key within an Access Grant dictates the resources and operations a Satellite will permit a user to access and perform. In contrast,
         an HD Encryption Key controls a user's ability to decrypt or encrypt buckets, path prefixes, and objects.</p>
       <p>At each level of the hierarchy, including buckets, path prefixes, and objects, a child HD Encryption Key is derived using a similar hierarchical
         deterministic process as the serialized API Key. However, the hierarchy of an API Key is based on access restrictions, whereas the hierarchy of
         encryption keys is based on the hierarchy of paths and objects.</p>
       <p>The primary distinction is that while a Satellite could generate restricted Access Grants that resemble those generated by a Uplink Client, it
         never has access to Encryption Keys.</p>

       <div class="img-wrapper">
         <img src="./images/encryption-keys-img.png" alt="img">
       </div>

       <strong>Supported Encryption Protocols</strong>

       <p>By default, the Uplink Client supports the AES-256-GCM encryption standard. However, since StorX is open source, developers have the
         flexibility to replace the default encryption standards with custom or preferred encryption schemes to align with their application's needs.</p>
       <p>Regardless of the encryption solution used, the crucial point is to encrypt your data. Keep in mind that your data is distributed across
         various storage nodes operated by strangers around the world, so ensuring data privacy and security is paramount. Unencrypted data not only
         exposes your data to the risk of compromise by potentially untrustworthy storage nodes but also poses an insider threat from rogue satellite
         operators.</p>

       <strong>Allow Decryption for Shared Object Access</strong>

       <p>Access Grants and encryption keys work in a similar fashion when sharing access to objects stored on the StorX Platform. Each Access
         Grant includes an Encryption Passphrase used to encrypt all objects and metadata stored on StorX. When creating a child Restricted Access
         Grant, two key components come into play:</p>

       <ol>
         <li>
           <p>A restricted API Key is generated within the child Restricted Access Grant, with a caveat that includes the specified restrictions.</p>
         </li>
         <li>
           <p>A child encryption key (or a set of appropriate descendant encryption keys) is derived from the encryption keys in the parent Access Grant.</p>
         </li>
       </ol>

       <p>If a child Restricted Access Grant restricts access to objects with a particular path prefix, not only does the API Key get limited to
         that path prefix, but the hierarchically deterministic derived encryption key is also restricted to decrypting or encrypting objects with
         the same path prefix. In essence, the child Encryption Key can't be used to access objects beyond its specified restrictions.</p>
       <p>When a restricted Access Grant is established, either via the Satellite Admin Console or by employing a Uplink client, it results in the
         automatic generation of an API Key and an Encryption Key, both configured to match the specified access limitations.</p>
       <p>At every tier within the hierarchy, encompassing buckets, object key prefixes, and individual objects, a subordinate HD Encryption Key is
         derived. This hierarchy is then encoded within the object and its metadata. Depending on an object's position within the hierarchy, if the
         encryption key of the parent is known, it's possible to derive an encryption key for any tier in the hierarchy below that point, extending
         to any child objects situated further down in the hierarchy.</p>
       <p>Much like the hierarchically structured Access Grants, developers, and applications are relieved of the burden of managing a set of keys.
         The encryption mechanism inherently encodes the hierarchy, enabling the dynamic derivation of shareable keys when needed. This set of shareable
         HD Encryption Keys is referred to as an "EncryptionAccess" within the Uplink Client.</p>


       <h3>Important Design Consideration</h3>

       <p>While the Access Grant is intended to be passed from an Uplink Client to a Satellite, the EncryptionAccess is designed to be shared
         peer-to-peer but never with the Satellite. For efficiency and ease of use, the Uplink Client's file-sharing functions create a 'security
         envelope' containing both the API Key and the EncryptionAccess, which is then shared peer-to-peer. The receiving peer Client Uplink separates
         the API Key, passes it to the Satellite to gain access to the object, and then decrypts the object client-side using the HD Key during the
         download process. This process is automated and abstracted behind the cp and share commands, simplifying the user experience.</p>


       <h3>Crucial Considerations for Key Management</h3>

       <p>End-to-end encryption places the onus of generating and upholding encryption keys for your data squarely on your shoulders.
         Losing your encryption keys equates to losing access to your data entirely.</p>

       <strong>A Word of Warning Regarding Encryption Keys</strong>

       <p>Throughout the documentation, it's crucial to emphasize three key aspects of your encryption keys. It is imperative that
         you fully grasp how encryption keys function within StorX DCS. The responsibility for encryption key management lies with
         you, your application, and your users.</p>
       <p><i>In the unfortunate event that you misplace your encryption keys, you will forfeit the capability to decrypt your data,
         rendering it inaccessible and effectively useless.</i></p>


       <p><strong>Your Encryption Keys Are Your Data:</strong> StorX DCS does not have access to your encryption keys. If you lose your
         encryption keys, your data becomes inaccessible, and it's essentially lost.</p>
       <p><strong>Backup Your Encryption Keys:</strong> It's crucial to back up your encryption keys securely. StorX DCS does not offer
         features to back up encryption keys. While a user interface reference implementation exists to ensure key backup, this
         process occurs on the client side.</p>
       <p><strong>Secure Your Encryption Keys:</strong> Exercise caution in how your application stores and transmits encryption keys. Keeping
         encryption and access management separate and implementing client-side encryption ensures that your data remains private and protected
         from processing, mining, or unauthorized access by StorX or any third parties.</p>
       <p><strong>Choose Complex Encryption Passphrases:</strong> Opt for strong and complex encryption passphrases. If your encryption key is
         easily guessable or compromised, you will need to re-encrypt and re-upload all your data to change your keys. This is a result of
         passphrase control being in your hands and the deterministic nature of encryption. </p>
       <p>To encourage proper user behavior, the access grant creation wizard on the Satellite dashboard prompts first-time users
         to create a 12-word passphrase</p>

       <h3>Determining When to Use Different Encryption Keys</h3>

       <p>While each Access Grant typically includes just one encryption key, there are scenarios where multiple keys become relevant and
         valuable. StorX DCS allows for the creation of multiple Access Grants with the same access authorization but different encryption
         keys. The default behavior of the Uplink Client is to display only data that it can decrypt. It's important to understand that it's
         possible to view the data in its encrypted state, but it is not feasible to derive or reverse engineer an encryption key from an
         Access Grant that lacks an encryption key specific to the data in question.</p>

       <p>Here are some considerations for when to use different encryption keys:</p>

       <ol>
         <li>
           <strong>Per-Bucket Encryption</strong>
           <p>The best practice is to use one encryption passphrase per bucket. If objects with the same path and object name are uploaded by
             different uplinks, but their encryption keys are derived from the same passphrase, the most recent upload will overwrite the older
             object. However, if the encryption keys are derived from different passphrases, the objects will be stored as separate entities. </p>
         </li>
         <li>
           <strong>Hierarchical Access Restriction </strong>
           <p>When an Access Grant is used to create a restricted Access Grant with limitations to a particular path prefix, the encryption key
             of the child Restricted Access Grant is derived from the parent Access Grant. In such cases, the parent Access Grant can decrypt data
             within the path restriction of both the parent and child Restricted Access Grant. However, the encryption key within the child Restricted
             Access Grant cannot be used to decrypt data outside the path restriction of the child. </p>
         </li>
         <li>
           <strong>Multiuser or Multi-Tenant Applications</strong>
           <p>In the context of multiuser or multi-tenant applications where data is stored on behalf of different users or entities, using different
             encryption passphrases can be common. Each user or tenant can be represented as a top-level path within the application's bucket. In
             this setup, each user or tenant is issued a child Restricted Access Grant scoped to their top-level path, allowing them to interact with
             their data but not access data outside their assigned path. </p>
         </li>
         <li>
           <strong>User-Defined Encryption Passphrases</strong>
           <p>Users can also overwrite the encryption key within a child Restricted Access Grant, giving them the ability to "choose" their
             encryption passphrase. However, if users lose access to this passphrase and the associated Access Grant, the data becomes irrecoverable. </p>
         </li>
       </ol>

       <p>In summary, using different encryption keys is advantageous in scenarios where data separation, hierarchical access restrictions, or
         multiuser/multi-tenant applications are involved. It provides enhanced control over data access and security. However, it's essential to
         manage encryption keys diligently, as losing them can result in permanent data loss.</p>

       <strong>Understanding StorX Connectors: Bridge the Gap</strong>

       <p>StorX Connectors play a pivotal role in bridging the gap between everyday applications and the underlying storage
         infrastructure, particularly when it comes to application data stored on StorX's decentralized cloud storage service.
         These connectors are instrumental in establishing connections between StorX and the applications offered by partners.</p>

       <strong>What Is a StorX Connector?</strong>

       <p>A StorX connector is an application-level integration that facilitates the utilization of decentralized cloud storage within consumer
         software. These connectors empower Satellites to gauge the volume of data associated with a specific bucket and provide attribution to
         the users of that data.</p>
       <p>In simpler terms, a Connector empowers application developers to manage data on the decentralized cloud, enabling storage, retrieval,
         and data management on behalf of the app users.</p>
       <p>StorX connectors stand apart from standard libuplink integrations, as they serve as a means for application developers and open source
         projects to programmatically monetize their cloud usage within the StorX network. This means that using StorX with your preferred open-source
         project can help lower your cloud storage expenses while also providing financial support to the project itself.</p>

       <strong>Building Connectors</strong>

       <p>The StorX Connector Framework encompasses a basic set of utility methods and operations that offer a consistent approach to integrating
         and orchestrating data sources, endpoints, and the StorX network. Some key aspects addressed by the framework include:</p>

       <ul>
         <li>Buffering/resource management</li>
         <li>Abstraction</li>
         <li>Data transformation:</li>
         <li>Configuration</li>
         <li>Authentication</li>
         <li>Logging</li>
       </ul>

       <p>Generally, a StorX connector directly interfaces with libuplink, StorX's native Go library designed to programmatically interact with StorX.
         The architectural diagram below provides a simplified overview of how a StorX Connector fits into the technology stack.</p>

       <div class="img-wrapper">
         <img src="./images/building-connector-img.png" alt="img">
       </div>

       <strong>Get Started and Monetize Open Source Software (OSS)</strong>

       <p>The StorX Connector Partner Program aims to empower a new wave of entrepreneurs who can effectively "be the cloud" and establish
         sustainable business models built on top of open-source software. By utilizing StorX with your favorite open-source projects, you
         not only reduce your cloud storage costs but also contribute financially to the project's success, creating a win-win scenario.</p>


       <h3>Data Model Consistency: StorX Cloud Storage's Commitment to Strong Read-After-Write Consistency</h3>

       <p>StorX cloud storage is unwavering in its commitment to providing robust and dependable read-after-write consistency, ensuring
         that your data remains reliable and accessible. StorX understands the critical importance of data model consistency for users and
         is dedicated to upholding this standard.</p>

       <strong>Data Structure Demystified: Navigate the Hierarchy</strong>

       <p>StorX cloud storage employs a structured hierarchy to logically segment data on the network, ensuring efficient organization and
         retrieval. Here's a breakdown of the key components in this data structure:</p>

       <strong>Projects</strong>

       <p>- Projects serve as a container for your data, allowing you to invite team members, manage billing, and control access for various applications or users.</p>

       <strong>Buckets</strong>

       <p>- Buckets are collections of objects, acting as a means to group related data. You can perform operations like uploading, downloading,
         listing, and deleting objects within a bucket. These objects can vary in size and type.</p>

       <strong>Objects</strong>

       <p>- Objects are the heart of your data storage. Each object typically comprises the data itself, a variable amount of metadata, and a
         globally unique identifier known as the "Object key," which distinguishes it within a bucket. Objects within buckets are represented
         by keys and can be optionally listed using the "/" delimiter. Crucially, all objects are end-to-end encrypted, ensuring robust data security.</p>

       <strong>Advanced Concepts</strong>

       <div class="img-wrapper">
         <img src="./images/advance-concept-img.png" alt="img">
       </div>

       <strong>Bucket</strong>

       <p>- As mentioned earlier, buckets represent collections of objects within StorX storage.</p>

       <strong>Object</strong>

       <p>- Objects are the individual units of data in StorX storage, consisting of the data, metadata, and a unique object key. These object
         keys are arbitrary strings of bytes and are encrypted before leaving the customer's application.</p>

       <strong>Object Key</strong>

       <p>- The object key is a unique identifier for a file within a bucket. It's an arbitrary byte string, often containing forward slashes at
         access control boundaries. These keys are encrypted by default before they leave the user's application.</p>

       <strong>Segment</strong>

       <p>- Segments represent single arrays of bytes, with a size limit of up to 64 MB.</p>

       <strong>Inline Segment</strong>

       <p>- An inline segment is a file that is smaller than the metadata required to track all its network pieces. These are stored directly
         on the satellite and not within the decentralized network.</p>

       <strong>Remote Segment</strong>

       <p>- In contrast, a remote segment is a larger segment that is erasure encoded and distributed across the network. It surpasses the metadata
         size needed for network tracking.</p>

       <strong>Stripe</strong>

       <p>- Stripes are subdivisions of a segment, serving as boundaries for encryption and erasure encoding. Erasure encoding operates on stripes
         individually, while encryption may span a small multiple of stripes at once. Audits are conducted at the stripe level.</p>

       <strong>Erasure Share</strong>

       <p>- When a stripe undergoes erasure encoding, it generates multiple pieces known as erasure shares. Only a subset of these shares is required
         to recover the original stripe. Each erasure share is assigned an index, indicating its position (e.g., first, second, etc.).</p>

       <strong>Piece</strong>

       <p>- Pieces come into play when a remote segment's stripes are erasure encoded. The erasure shares with the same index are concatenated to form
         a piece. If a stripe generates n erasure shares, then there are n pieces for that remote segment. The nth piece encompasses all erasure shares
         from the segment's stripes.</p>

       <p>This comprehensive data structure ensures the efficient organization and retrieval of data while prioritizing data security and redundancy.</p>


       <h3>Embrace Decentralization</h3>

       <p>Decentralized data storage offers enhanced security and privacy benefits. Compared to conventional
         centralized data storage, decentralized cloud storage proves to be a formidable fortress against
         potential attacks. Within a decentralized network, files are fragmented and distributed across numerous
         nodes situated in diverse physical locations worldwide. StorX DCS employs Erasure Coding to disperse file
         fragments across a multitude of nodes, each residing in different corners of the globe.</p>

       <p>There are several compelling reasons to opt for decentralized storage instead of legacy alternatives:</p>

       <ol>
         <li>Enhanced Privacy and Security</li>
         <li>Streamlined and Cost-Effective Pricing</li>
         <li>Seamless Integration</li>
       </ol>

       <p>One of the key drivers for embracing decentralization is the reduction of infrastructure costs associated
         with maintenance, utilities, and bandwidth. We firmly believe that many smaller operators possess untapped
         resources on the network's periphery. Drawing from our extensive experience in developing decentralized
         storage networks, we've uncovered a reservoir of resources that are either dormant or underutilized,
         presenting an opportunity for affordable and geographically dispersed cloud storage solutions.</p>

       <p>Our commitment to decentralization extends to core infrastructure like storage, and it stems from our
         vision of providing a viable alternative to the handful of dominant centralized storage entities currently
         monopolizing the market. We recognize the inherent risks in entrusting a single entity, corporation, or
         organization with a significant portion of the world's data. In fact, we contend that there is an implicit
         cost associated with relying on any third party to safeguard personal data.</p>


       <h3>Notable Benefits of Decentralized Storage</h3>

       <p><strong>End-to-End Encryption:</strong> This cryptographic technique encrypts data at the sender's
         end before transmission to a server, such as a cloud storage service. Client-side encryption utilizes
         encryption keys inaccessible to the service provider (in this case, StorX), making it exceedingly
         challenging, if not impossible, for service providers to decrypt stored data. This empowers the
         development of applications in which providers cannot access user-stored data, ensuring a high level
         of privacy. source: <a href="https://en.wikipedia.org/wiki/Client-side_encryption" target="_blank">wikipedia
           end-to-end encryption</a></p>

       <p><strong>File Redundancy: </strong> In coding theory, an erasure code is employed for forward error correction
         (FEC) under the assumption of bit erasures, transforming a message of k symbols into a longer message (code word)
         of n symbols. This enables the recovery of the original message from a subset of the n symbols, with the fraction
         r = k/n referred to as the code rate. The fraction k’/k, indicating the number of symbols required for recovery, is
         known as reception efficiency. <a href="https://en.wikipedia.org/wiki/Erasure_code" target="_blank">wikipedia Erasure code</a></p>

       <div class="img-wrapper">
         <img src="./images/decentralized-storage-img.png" alt="img">
       </div>

       <p>You can delve deeper into erasure codes within StorX DCS under the "File Redundancy" section in the "Concepts" segment.</p>

       <p><strong>Data Repair</strong> becomes imperative when the number of available file fragments held within the
         network approaches the minimum threshold at which file recovery becomes impossible. When this threshold is near,
         the network initiates data repair, ensuring a sufficient number of available fragments to prevent irretrievability.
         Further insights on data repair in StorX DCS can be obtained from the "File Repair" section within the "Concepts."
       </p>
       <p><strong>File Audit</strong> involves testing the successful retrieval of a random fragment from a node storing it.
         File audits are consistently applied to guarantee the durability of files within StorX DCS. This audit service
         functions as a highly scalable and performant analog to the consensus mechanisms, typically distributed ledgers,
         employed in other decentralized storage services.</p>


       <h3>Coordination Avoidance</h3>

       <p>In contrast to the conventional approach of reaching a global consensus regarding the entire state of the network, such
         as seen in blockchains like Ethereum, the StorX Network adopts a Coordination Avoidance strategy. This network doesn't
         require a universal consensus, adhering to the principles of the CAP Theorem, as each uplink user's primary concern is
         the ability to recover their individual files.</p>

       <strong>Advantages Over Coordination-Dependent Systems</strong>

       <p>By implementing coordination avoidance within StorX DCS, we achieve superior performance and scalability in comparison
         to other decentralized systems. These two aspects are paramount in securing widespread adoption among traditional storage
         users. Decentralized systems reliant on coordination, such as Bitcoin, demand an ever-increasing resource allocation as they
         expand. To compete effectively with centralized cloud storage giants like Amazon S3, Microsoft Azure, and Google Cloud, StorX
         DCS must be capable of scaling into the exabyte range and beyond, a goal we are confident it can attain.</p>

       <p>Our approach, which decentralizes both the storage and metadata tiers of the network, empowers greater scalability,
         performance, and reliability compared to systems dependent on consensus-seeking.</p>


       <strong>Comparison to Blockchain Networks</strong>

       <p>Blockchain networks offer robust guarantees, but they come at the price of substantial coordination overhead.
         Coordination isn't always imperative for correctness, and minimizing it is pivotal for optimizing scalability,
         availability, and high-performance in database systems. One foundational design choice in the StorX network was
         to forego blockchain consensus for file transfers to enhance these characteristics. StorX adopts a pragmatic stance
         in avoiding blockchain consensus while ensuring the correctness of file transfers. However, by default, StorX utilizes
         blockchain consensus, employing the Ethereum-based STORX token for payment processing to storage node operators.</p>

       <p>StorX DCS represents an enterprise-ready iteration of the StorX network, offering guaranteed SLAs. All user uploads
         and downloads on StorX DCS rely on metadata from StorX DCS Satellites, which function as specialized network nodes
         responsible for auditing storage nodes and verifying the proper storage of files and metadata for users.</p>

       <div class="img-wrapper">
         <img src="./images/comparison-blockchain-img.png" alt="img">
       </div>

       <p>As depicted in the architectural overview above, the StorX network comprises three primary peer categories. All of
         these are open-source and can be operated by third parties, underscoring the network's fundamental decentralization.</p>

       <p>The StorX network harnesses the decentralized nature of storage nodes and Satellites to establish network partitions
         that segregate users and file transfers from one another. This segmentation minimizes the need for coordination across
         the StorX network. For organizations with exceptionally high throughput demands, the option to operate their own Satellite
         exists. This approach reduces coordination overhead with the broader StorX DCS and grants users the flexibility to make
         autonomous decisions regarding their Satellite's choice of database infrastructure and potential relaxation of consistency
         guarantees as needed.</p>

       <h3>Definitions:</h3>

       <p>The StorX DCS service leverages a diverse set of technologies, including robust encryption and erasure codes, to
         establish a heightened level of privacy and security throughout a network of peer categories. While some of the
         terminology used may be familiar, and others new, you'll likely discover valuable explanations here for any unfamiliar
         terms or for familiar words used in a new context.</p>

       <p><strong>Peer Category:</strong> A unified assembly of network services and duties. In our network, there are three distinct peer categories
         representing services: storage nodes, Uplinks, and Satellites.</p>

       <p><strong>Storage Node:</strong> This peer category serves as the custodian of data for others and receives compensation for storage and
         bandwidth. All data stored on storage nodes undergoes client-side encryption and erasure coding.</p>

       <p><strong>Uplink:</strong> This peer category represents any application or service implementing libuplink to store and retrieve data.
         Unlike the other two categories, an Uplink isn't necessarily expected to remain continuously online and is relatively
         lightweight. It carries out encryption, erasure encoding, and collaborates with other peer categories on behalf of the
         customer or client. Object data stored by the Uplink client is encrypted by the client, including metadata.</p>

       <p><strong>Libuplink:</strong> A library that supplies all the necessary functions for direct interaction with storage nodes and Satellites.
         This library will be available in various programming languages.</p>

       <p><strong>Gateway:</strong> A service that provides an interoperable layer between other object storage services, such as Amazon S3, and
         libuplink, thereby exposing an Amazon S3-compatible API.</p>

       <p><strong>Gateway ST:</strong> A single-tenant, self-hosted S3-compatible gateway service, included as part of the StorX DCS developer tools/SDK.</p>

       <p><strong>Gateway MT:</strong> A multi-tenant, multi-region, cloud-hosted S3-compatible gateway service, included as part of the StorX
         DCS service. This service is considered server-side encrypted rather than end-to-end encrypted because it temporarily
         manages encryption for you. While more complex, you can operate it on your infrastructure if desired.</p>

       <p><strong>Gateway MT:</strong> A multi-tenant, multi-region, cloud-hosted S3-compatible gateway service, included as part of the StorX
         DCS service. This service is considered server-side encrypted rather than end-to-end encrypted because it temporarily
         manages encryption for you. While more complex, you can operate it on your infrastructure if desired.</p>

       <p><strong>Uplink CLI:</strong> A command-line interface for uploading and downloading files from the network, managing permissions,
         sharing, and handling accounts.</p>

       <p><strong>Satellite:</strong> A peer category and one of the central components of the StorX network. The satellite actively participates
         in the node discovery system, caches node address information, stores per-object metadata, upholds storage node reputation,
         aggregates billing data, compensates storage nodes, conducts audits and repairs, and manages authorization and user
         accounts. Users have accounts on specific Satellites and place their trust in them. While any user can run their Satellite,
         many may prefer to avoid operational complexities by creating an account on another Satellite hosted by a trusted third
         party like StorX Labs, a friend, a group, or an organization. StorX Labs satellites are operated under the StorX DCS brand.
         This component carries several primary responsibilities, including developer account registration and management, API
         credential and access management, billing and payment processing, audit and repair tasks, and garbage collection and
         other maintenance duties.</p>

       <p><strong>Satellite Developer Account:</strong> This contains essential information about users and is used to grant them access to StorX
         DCS. User account data includes the user's name, email, password, and payment methods. This data is not client-side
         encrypted, allowing it to be displayed in the satellite user interface.</p>

       <p><strong>Strong Encryption:</strong> A robust encryption algorithm that can guarantee the confidentiality of sensitive data. Decrypting
         data encrypted with strong encryption methods is either infeasible or economically unjustifiable within the useful lifespan
         of the data, due to the time and computational resources required.</p>

       <p><strong>Weak Encryption:</strong> A weaker encryption algorithm that cannot ensure the confidentiality of sensitive data. Outdated encryption
         algorithms, like DES (or even 3DES), no longer provide adequate protection for sensitive data. The effectiveness of
         encryption algorithms depends on key size as one of the primary factors for cryptographic strength. Cryptographic strength
         is often evaluated based on the time and computational power needed to generate a valid key. Advances in computing and
         cryptanalysis have made it feasible to obtain small encryption keys within a reasonable timeframe. For instance, the 56-bit
         key used in DES posed a significant computational challenge in the 1970s when the algorithm was developed, but today, DES
         can be cracked in less than a day using readily available equipment.</p>

       <p><strong>Backdoor:</strong> A backdoor denotes any method through which both authorized and unauthorized users can bypass standard security
         measures and gain high-level user access, often referred to as root access, to a computer system, network, or software application.</p>

       <p><strong>Open-source:</strong> Open-source software refers to software with publicly accessible source code that can be reviewed, modified,
         and enhanced by anyone.</p>

       <p><strong>Privacy Policy:</strong> A statement or legal document that discloses various practices related to collecting, using, disclosing,
         and managing customer or client data by a party. Personal information may encompass details that can identify an individual,
         including but not limited to their name, address, date of birth, marital status, contact information, ID issuance and expiry
         dates, financial records, credit information, medical history, travel information, and intentions to acquire goods and services.
         It typically outlines the party's approach to data collection, storage, and release, specifying what information is collected
         and whether it remains confidential, shared with partners, or sold to other entities. Privacy policies tend to provide a broader,
         more general overview, as opposed to more detailed and specific data use statements.</p>

       <p><strong>Data Element Definitions:</strong> Data stored on the network is structured to align with conventional object storage principles,
         incorporating attributes adapted to the distributed storage model.</p>

       <p><strong>Project:</strong> A project serves as the fundamental unit for aggregating usage data, calculating fees for invoicing, and collecting
         payments. By default, user accounts are limited to a few projects, but users can request and pay for additional ones. Multiple
         users can be added to a project team. Within each project, usage data is tracked at the bucket level and subsequently aggregated
         for invoicing purposes. Project names are not client-side encrypted to allow them to be displayed in the satellite user interface.</p>

       <p><strong>Bucket:</strong> A bucket represents an unbounded but named collection of files identified by paths. Each object has a unique object key
         or path within a specific bucket. Bucket names are not client-side encrypted to facilitate their rendering in the satellite user
         interface.</p>

       <p><strong>Object Key (or Path):</strong> An object key serves as a unique identifier for an object or file within a bucket. It consists of arbitrary
         strings of bytes, with forward slashes denoting access control boundaries. For instance, an example path might appear as
         "videos/carlsagan/gloriousdawn.mp4," with path components being "videos," "carlsagan," and "gloriousdawn.mp4." Object keys are
         client-side encrypted.</p>

       <p><strong>Object or File:</strong> The primary data entity in our system is an object or file, referred to by its object key. It can contain any
         amount of bytes, with no minimum or maximum size. An object is represented by an ordered collection of one or more segments,
         each having a fixed maximum size. Furthermore, objects can accommodate a limited number of user-defined key-value fields to store
         user metadata. Like object keys, object data is client-side encrypted.</p>

       <p><strong>Segment:</strong> A segment is a representation of a single array of bytes, typically ranging from 0 up to a system-configurable maximum
         segment size, such as the 64MB maximum segment size on StorX DCS Satellites. Smaller objects under 64MB are stored as one segment,
         while larger objects are divided into multiple 64MB segments. Each segment is stored across the network in 80 pieces, with only 29
         of those pieces required to reconstruct a segment. All segments are necessary to reconstitute an object. Segment data is client-side
         encrypted.</p>

       <p><strong>Remote Segment:</strong> A remote segment is a segment that undergoes erasure encoding and is distributed across the network. A remote
         segment is larger than the metadata needed for bookkeeping, including information like the IDs of nodes where the data is stored.
         Remote segment data is client-side encrypted.</p>

       <p><strong>Inline Segment:</strong> In cases where the data represented by an inline segment requires less space than the equivalent data to track
         which nodes store it, the data is stored "inline" instead of on nodes. Inline segment data is client-side encrypted.</p>

       <p><strong>Stripe:</strong> A stripe further subdivides a segment and represents a fixed amount of bytes used as a boundary for encryption and erasure
         encoding. Erasure encoding is performed individually on stripes, while encryption may be applied to a small multiple of stripes at
         once. All segments are encrypted, but only remote segments undergo erasure encoding on stripes. Stripes serve as the unit on which
         audits are conducted.</p>

       <p><strong>Erasure Share:</strong> When a stripe undergoes erasure encoding, it generates multiple pieces referred to as erasure shares. Only a subset
         of these erasure shares is required to recover the original stripe. Each erasure share is identified by an index, indicating its
         position (e.g., the first, the second, and so on). Data is client-side encrypted before it's erasure encoded into erasure shares.</p>

       <p><strong>Piece:</strong> Upon erasure encoding the stripes of a remote segment, erasure shares with the same index are concatenated to form a piece.
         If there are "n" erasure shares after erasure encoding a stripe, there will be "n" pieces generated after processing a remote segment.
         The "i-th" piece represents the concatenation of all "i-th" erasure shares from that segment's stripes.</p>

       <p><strong>Metadata:</strong> Metadata encompasses data stored about the objects present on the service. It includes object key data, pointer data,
         encrypted per-object randomized salted encryption key-related data, and user-defined metadata. Metadata is client-side encrypted.</p>

       <p><strong>Pointer:</strong> A pointer is a subset of metadata that serves as a data structure containing either inline segment data or records of which
         storage nodes contain the pieces of a remote segment. It also includes other per-file metadata. Pointer data is not client-side encrypted
         , allowing a Satellite to perform segment repairs and replace the piece locations.</p>

       <strong>Erasure Code Definitions:</strong>
       <p>Data redundancy within the network is established through erasure codes, which employ a technique for data protection. In this approach,
         data is segmented into components, each of which is expanded and encoded with additional redundant data. These encoded components are then
         distributed across various storage locations to mitigate the risk of data loss in case one of these locations becomes inaccessible.</p>

       <strong>Erasure Code Ratio:</strong>
       <p>An erasure code is commonly expressed as a ratio of two values: "k" and "n." In a k, n erasure code, a block of data is encoded, resulting
         in a total of "n" erasure shares. However, only "k" of these shares are needed to reconstruct the original data block. The specific
         combination of shares required for recovery can vary; it could be even-numbered shares, odd-numbered shares, the first "k" shares,
         the last "k" shares, or any "k" shares of your choice. This flexibility allows recovery using any set of "k" shares, adding resilience.</p>

       <strong>Expansion Factor:</strong>
       <p>The expansion factor is the degree of additional data stored to achieve redundancy based on a targeted durability level. For durability
         achieved through erasure codes, the expansion factor is computed by dividing "n" by "k." On the other hand, when durability is achieved
         through replication, the expansion factor is calculated by multiplying the number of replicas by 100%. Erasure codes, at any given expansion
         factor, provide significantly higher durability compared to replication.</p>

       <strong>Erasure Code Variables:</strong>
       <p>"k" = 29: This represents the number of pieces required to reassemble a segment. Any combination of 29 pieces from a segment can be used
         to reconstruct the entire segment.</p>
       <p>"m" = 35: In the context of an Uplink, this is the number of pieces it will attempt to download when fetching a segment. The Uplink will
         cease downloading pieces after successfully retrieving 29 of them. The "m" value also serves as the repair threshold for a segment. Satellites
         monitor the availability of storage nodes and if too many nodes become unavailable, jeopardizing the segment's durability, the Satellite will
         recreate the missing pieces through file repair. The repaired pieces are then stored on diverse, healthy storage nodes. The repair threshold
         may be overridden, and for StorX Satellites, it's set to 54.</p>
       <p>"o" = 80: This denotes the maximum number of pieces stored for a segment.</p>
       <p>"n" = 130: In the context of an Uplink, this represents the number of pieces it aims to upload to various storage nodes when storing a segment.</p>

       <strong>Multipart Upload:</strong>
       <p>Multipart Upload is a feature that facilitates the efficient uploading of large files by dividing them into smaller components. Each part of
         a multipart upload is stored as one or more segments. This allows a single object to be uploaded as a collection of parts, with each part being
         an integral section of the data forming the object. These parts can be uploaded independently, in parallel, and in any order. The process permits
         pausing and resuming uploads, and if a part fails to upload, it can be re-uploaded without affecting other parts. The StorX DCS Gateway determines
         how parts are divided into one or more segments based on whether the part size exceeds the default segment size (64MB). Users can configure the
         part size in applications using Multipart Upload.</p>

       <ul>
         <li><strong>Part:</strong> A part is an individual section of an object that has been separated into multiple pieces during a multipart upload.
           Each part is further broken down into one or more segments.</li>
         <li><strong>Graceful Exit:</strong> A graceful exit is a feature that enables a storage node to transition the data it stores to other nodes on
           the network without initiating the repair process, as part of the process of leaving the network.</li>
         <li><strong>Value Attribution:</strong> Value Attribution is a system offered through our partner program, providing various programs for partners
           who refer business to us. It tracks referrals using a system known as Value Attribution.</li>
         <li><strong>Value Attribution Code:</strong> Partners are assigned a unique code that is passed between and to a User Agent to monitor StorX DCS
           usage associated with a partner's application.</li>
       </ul>


       <strong>Encryption-related Terms:</strong>

       <p><strong>Segment:</strong> The largest subdivision of an object or part, typically consistent in size. However, the last segment is generally smaller
         than the others.</p>

       <p>Object Key or Path: The representation of an object's "location" within the system. Paths consist of a series of strings separated by
         slashes (e.g., this/is/an/object.txt). On the StorX network, the Satellite uses object keys to track object metadata and pointers to
         storage nodes that store encrypted object content.</p>

       <p><strong>Root Secret:</strong> A private client-side encryption key defined in the client configuration, used to derive keys for encrypting and decrypting
         data stored on the service.</p>

       <p>Object Encryption Key: A key derived from the root secret and the object key. Each path component in a forward-slash separated object
         key corresponds to a unique path key, which is used to derive new path keys for lower-level path items.</p>

       <p><strong>Random Key:</strong> A randomly generated key used to encrypt segment content and metadata.</p>

       <p><strong>Derived Key:</strong> A key derived from the path key for the lowest-level path element, used to encrypt the random key before storing it in a
         segment's metadata.</p>

       <p>HMAC (Hash-based Message Authentication Code): HMACs are generated using path elements and encryption keys to derive new keys for lower
         levels of the path. This mechanism simplifies generating lower-level keys from higher-level keys, without enabling the reverse operation
         of generating higher-level keys from lower-level ones.</p>

       <p>AES-GCM (Advanced Encryption Standard-Galois/Counter Mode): An authenticated encryption algorithm that combines the Advanced Encryption
         Standard with the Galois/Counter mode to encrypt data blocks.</p>

       <p><strong>Secretbox:</strong> An authenticated encryption algorithm from the NaCl library, which combines the Salsa20 encryption cipher with the Poly1305
         message authentication code.</p>

       <strong>Access Management-related Terms:</strong>

       <p><strong>Access Grant:</strong> An encoded string that contains an API Key, an Encryption store, and the address of the Satellite storing object
         metadata, designed for sharing access to objects stored on StorX DCS.</p>

       <p><strong>API Key:</strong> A unique string generated for a project to authorize access management of data on the service. The API key serves as an
         authorization token based on a mechanism called macaroons, and it's sent to the Satellite to validate requests.</p>

       <p><strong>Encryption Store:</strong> A collection of encryption key information that enables users to access one or more objects, object key prefixes,
         or buckets.</p>

       <p>Restricted Access Grant: An access grant derived from another access grant with one or more restrictions applied to the internal API
         key, encryption store, or both.</p>

       <p><strong>Caveat:</strong> An access restriction encoded into an API key generated client-side and interpreted by a Satellite. Caveats can restrict specific
         operations (Read, Write, Delete, List), limit operations on particular buckets, path components, or path prefixes, or define time windows
         for operation permissions.</p>

     </div>
   </section>

    <footer>
      <div class="container">
        <div class="row g-0">
          <div class="col-xl-3 col-lg-5 col-md-3">
            <a href="./index.html" class="footer-logo">
              <img src="./images/footer-logo.svg" alt="footer-logo" />
            </a>
            <div class="text-wrapper">
              <p>
                Build on XinFin (XDC)<br />
                Blockchain Network as an <br />
                open source initiative.
              </p>
            </div>
          </div>
          <div class="col-xl-9 col-lg-7 col-md-9 my-4 my-md-0">
            <div class="links-wrapper">
              <div class="links-item">
                <h4>StorX</h4>
                <ul>
                  <li><a href="https://storx.io/" target="_blank">Store Data</a></li>
                  <li><a href="https://farmer.storx.io/" target="_blank">Host A Storage Node</a></li>
                  <li><a href="wallets-&-exchanges.html">Wallets & Exchanges</a></li>
                  <li><a href="community-bounty.html">Community Bounty</a></li>
                </ul>
              </div>
              <div class="links-item">
                <h4>Solutions</h4>
                <ul>
                  <li><a href="storx-secured-storage.html">StorX Secured Storage</a></li>
                  <li><a href="storx-for-saas-backup.html">StorX For SaaS Backup</a></li>
                  <li><a href="storx-onprem.html">StorX Self Hosted Cloud</a></li>
                </ul>
              </div>
              <div class="links-item">
                <h4>Resource</h4>
                <ul>
                  <li><a href="faqs.html">FAQ</a></li>
                  <li><a href="javascript:void(0)">Documentation</a></li>
                  <li><a href="https://medium.com/storx-network" target="_blank">Blog</a></li>
                  <li><a href="./pdf/brand-assets.pdf" download target="_blank">Brand Assets</a></li>
                </ul>
              </div>
              <div class="links-item">
                <h4>Get Started</h4>
                <ul>
                  <li><a href="become-partner.html">Become Partner</a></li>
                  <li><a href="contact-us.html">Contact Sales</a></li>
                  <li><a href="terms-condition.html">Disclaimer</a></li>
                </ul>
                <a href="https://storx.io/new" target="_blank" class="btn-style red cornered-btn text-white"
                >Start StorX For Free</a
                >
              </div>
            </div>
          </div>
        </div>
        <div class="row">
          <p class="footer-bottom-text text-center">
            Copyright StorX Foundation 2023 -24, All Rights Reserved
          </p>
        </div>
      </div>
    </footer>

    <script src="./js/jquery-3.7.0.min.js"></script>
    <script src="./js/bootstrap.bundle.min.js"></script>
    <script src="./js/popper.min.js"></script>
    <script src="./js/owl.carousel.min.js"></script>
    <script src="./js/main.js"></script>
  </body>
</html>
